import argparse
from collections import Counter
import json
import os
import re

import numpy as np


SUCCESS_EMOJIS = ["✅️✅️✅️✅️✅️✅️", "✅️", "✅️(success)"]

def safe_div(x: int, y: int) -> float:
    if y == 0:
        return 0.0
    else:
        return x / y

def get_emoji(entry):
    if "result_emoji" in entry and entry["result_emoji"] is not None:
        return entry["result_emoji"]
    elif (match := re.search(r"^(([💥️❌️✅️]+)(\([^\)]*\))?) ", entry.get("result_output", ""), flags=re.MULTILINE)):
        return match.group(1)
    elif "TimeoutExpired" in entry.get("result_output", ""):
        return "⏰"
    elif "failed with error (deterministic) timeout at" in entry.get("result_output", ""):
        return "❤️"
    elif "unknown constant" in entry.get("result_output", ""):
        # this commonly occurs when something generated by `@[simps]` is selected as evaluation theorem
        return "not tested"
    else:
        return "not tested"

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Prints tactic benchmark results.")
    parser.add_argument("results_files", nargs="+", help="The path to the results files.")
    parser.add_argument("--verbose", action="store_true", help="Print loss/gains.")
    parser.add_argument("--proof_length", action="store_true", help="Print proof lengths")
    parser.add_argument("--plot", action="store_true", help="Plot results.")
    # parser.add_argument("--ablate", type=str, default=None, help="Ablate for a 'setting', assuming filenames are of the form hammer_k1[-setting].json.")
    args = parser.parse_args()

    results_files: list[str] = args.results_files

    cumulative_solved_decls = set()
    cumulative_all_decls: set[str] = set()
    decls_tested_by_all: set[str] | None = None  # some declarations (currently) aren't tested because e.g. they are `def`

    # if args.proof_length is true, maps decl name to (proof length in lines, #GT premises)
    proof_str: dict[str, str | None] = {}
    proof_length: dict[str, int | None] = {}
    proof_gt_size: dict[str, int] = {}

    counters: list[tuple[str, Counter, int]] = []

    # first pass: set cumulative_all_decls and decls_tested_by_all
    for results_file in results_files:
        this_cumulative_tested_decls = set()

        with open(results_file) as f:
            results: dict = json.load(f)

        for decl_name, entry in results.items():
            emoji = get_emoji(entry)

            if emoji != "not tested":
                this_cumulative_tested_decls.add(decl_name)
            cumulative_all_decls.add(decl_name)

            if args.proof_length:
                module = entry["module"]
                if os.path.exists(full_proof_filename := f"/home/thomaszh/ntp-toolkit/Examples/Mathlib/FullProof/{module}.jsonl"):
                    with open(full_proof_filename) as f:
                        for l in f:
                            full_proof_data = json.loads(l)
                            # print(module, decl_name, full_proof_data["declName"])
                            if full_proof_data["declName"] == decl_name:
                                proof = full_proof_data["proof"].strip().removeprefix(":=").strip().removeprefix("by").strip().removeprefix("where").strip()
                                # print(proof)
                                proof_str[decl_name] = proof
                                proof_length[decl_name] = 1 + proof.count("\n")
                                break
                if decl_name not in proof_str:
                    print(f"warning: Full proof data for {decl_name} not found")
                    proof_str[decl_name] = None
                    proof_length[decl_name] = None
                with open("/home/thomaszh/premise-retrieval/retrieved_premises/eval_decls_mar03.json") as f:
                    for gt_entry in json.load(f):
                        if gt_entry["decl_name"] == decl_name:
                            proof_gt_size[decl_name] = len(gt_entry["gt_premises"])
                            break
                    else:
                        raise ValueError(f"GT premises for {decl_name} not found")

        if decls_tested_by_all is None:
            decls_tested_by_all = this_cumulative_tested_decls
        else:
            decls_tested_by_all &= this_cumulative_tested_decls

    # second main pass
    for results_file in results_files:
        print(results_file)
        with open(results_file) as f:
            results: dict = json.load(f)

        emojis = []
        gains = set()
        losses = set()
        loss_emojis = []
        for decl_name, entry in results.items():
            # print(*entry.keys())
            # print(entry["result_output"])
            emoji = get_emoji(entry)

            if not decl_name in decls_tested_by_all:
                continue

            emojis.append(emoji)

            if emoji in SUCCESS_EMOJIS:
                if decl_name not in cumulative_solved_decls:
                    cumulative_solved_decls.add(decl_name)
                    gains.add(decl_name)
                    if args.verbose:
                        print("+", decl_name, emoji)
            elif decl_name in cumulative_solved_decls:
                if args.verbose:
                    print("-", decl_name, emoji)
                losses.add(decl_name)
                loss_emojis.append(emoji)

        counter = Counter(emojis)

        num_solved = sum(counter[success_emoji] for success_emoji in SUCCESS_EMOJIS)
        num_decls = counter.total()
        num_tested = num_decls - counter["not tested"]
        num_without_bugs = num_tested - counter["💥️💥️💥️💥️💥️💥️"] - counter["⏰"]

        print(counter)
        # print(f"Number of solved theorems: {num_solved:4d} ({safe_div(num_solved, num_decls):.4%})")
        print(f"Number of solved theorems: {num_solved} ({safe_div(num_solved, num_tested):.4%} out of {num_tested} tested)")
        # print(f"Percentage solved (out of runs without bugs): {safe_div(num_solved, num_without_bugs):.4%}")
        print(f"Gains: {len(gains):4d}, losses: {len(losses):4d} ({Counter(loss_emojis)})")
        # print(f"Gains: {gains}")
        # print(f"Losses: {losses}")
        # print("Losses:", *[e + ' ' + l for e, l in zip(loss_emojis, losses)], sep="\n")
        print(f"Current cumulative solved theorems: {len(cumulative_solved_decls):4d}")
        print()

        counters.append((results_file, counter, len(cumulative_solved_decls)))


    if args.proof_length:
        for decl_name in cumulative_solved_decls:
            print(proof_str[decl_name])
            print("Success", proof_length[decl_name], proof_gt_size[decl_name])
        for decl_name in decls_tested_by_all - cumulative_solved_decls:  # type: ignore
            print("Failure", proof_length[decl_name], proof_gt_size[decl_name])
    print(f"Total number of theorems: {len(cumulative_all_decls)}")
    print(f"Cumulative percentage solved: {safe_div(len(cumulative_solved_decls), len(decls_tested_by_all)):.4%} (out of {len(decls_tested_by_all)} tested)")  # type: ignore

    # print(f"All tested:", ','.join(f'"{d}"' for d in decls_tested_by_all))
    # print(f"All solved:", ','.join(f'"{d}"' for d in cumulative_solved_decls))

    # if args.ablate is not None:
    #     counters_map = {results_file: counter for (results_file, counter, _) in counters}
    #     num_solved_default = []
    #     num_solved_with_setting = []
    #     diffs = []
    #     setting_string = f"-{args.ablate}"
    #     for results_file, counter, _ in counters:
    #         if setting_string in results_file and (results_file_without_setting := results_file.replace(setting_string, "", 1)) in counters_map:
    #             counter_without_setting = counters_map[results_file_without_setting]
    #             num_solved_with_setting.append(sum(counter[success_emoji] for success_emoji in SUCCESS_EMOJIS))
    #             num_solved_default.append(sum(counter_without_setting[success_emoji] for success_emoji in SUCCESS_EMOJIS))
    #             diffs.append(num_solved_with_setting[-1] - num_solved_default[-1])
    #     print(f"Average performance increase by using {args.ablate}: {np.mean(diffs)} ± {np.std(diffs)}")

    if args.plot:
        import matplotlib.pyplot as plt
        import numpy as np

        # Data parsed from the results
        # k_values = [1, 2, 4, 8, 16, 32, 64, 128]
        result_emojis = {
            "✅️": ("Solved", "#008000"),
            "❌️": ("Failed", "#5F9EA0"),
            "💥️": ("Uncaught error", "#800080"),
            "💥️(subgoals)": ("Error: subgoals", "#800080"),
            "💥️(notDefEq)": ("Error: notDefEq", "#a020a0"),
            "💥️(noJSON)": ("Error: noJSON", "#c040c0"),

            "✅️✅️✅️✅️✅️✅️": ("Solved", "#44ce1b"),
            "✅️✅️✅️✅️💥️❌️": ("Reconstruction error", "#bbdb44"),
            "✅️✅️✅️💥️❌️❌️": ("Zipperposition fail", "#f7e379"),
            "✅️✅️💥️❌️❌️❌️": ("TPTP error", "#f2a134"),
            "💥️💥️💥️💥️💥️💥️": ("Uncaught error", "#800080"),
            "⏰": ("Uncaught timeout", "#9e9e9e"),
            "✅️💥️❌️❌️❌️❌️": ("Preprocessing error", "#e51f1f"),
            "not tested": ("N/A", "#607d8b"),
        }

        # Preparing the bar positions and labels
        y_pos = np.arange(len(counters))[::-1]
        bar_width = 0.85

        # Stacking the bar chart
        fig, ax = plt.subplots(figsize=(10, 7))
        cumulative = np.zeros(len(counters))

        for i, (result_emoji, (label, color)) in enumerate(result_emojis.items()):
            counts = [counter[result_emoji] for _, counter, _ in counters]
            if result_emoji == "not tested":
                continue
            if all(c == 0 for c in counts):
                continue
            # if result_emoji != "✅️💥️❌️❌️❌️❌️":
            #     continue
            ax.barh(
                y_pos,
                counts,
                left=cumulative,
                height=bar_width,
                label=label,
                color=color,
            )
            cumulative += counts

        # plot cumulative pass rate
        cumulative_pass = [cumulative for _, _, cumulative in counters]
        ax.plot(cumulative_pass, y_pos)

        # Labels and styling
        ax.set_yticks(y_pos)
        ax.set_yticklabels([
            result_file.split("/")[-1].split(".")[0].replace("exact", "exact?")
            for result_file, _, _ in counters
        ])
        ax.set_xlabel("Number of Theorems")
        ax.set_title("Theorem Proving Results by k Value")
        ax.legend(title="Result Type", bbox_to_anchor=(1.05, 1), loc="upper left")
        plt.tight_layout()

        # Show the plot
        plt.savefig("plot.png", bbox_inches="tight", transparent=True)
        plt.show()
